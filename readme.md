# Стратегия

## Задача

1. Реализовать возможность настройки режима использования видеокарт: Gaming, Workstation, DataCenter.
**Интерфейсы классов менять нельзя, так как они могут активно использоваться в другом коде.**

## Решение "в лоб" (без использования паттернов)

1. В базовом классе ``GPU`` добавить перечисление ``enum class GPUUsageType { Gaming, Workstation, DataCenter }`` и поле ``usageType``.

2. В каждом подклассе переписать метод ``Use()``, чтобы он учитывал usageType:
    - ``Gaming`` — игровые API, высокие частоты, DLSS.
    - ``Workstation`` — ECC-память, сертификация, мультимониторные конфигурации.
    - ``DataCenter`` — оптимизация для стоек, тензорные ядра, виртуализация.

## Решение с использованием паттерна "Стратегия"

1. Создать абстрактный класс ``UsageStrategy`` и его реализации:
    - ``GamingUsageStrategy``
    - ``WorkstationUsageStrategy``
    - ``DataCenterUsageStrategy``
2. Разработать фабрику для создания стратегий по ``GPUUsageType``.
3. Инкапсулировать указатель на ``UsageStrategy`` внутри ``GPU``.
4. Добавить метод ``SetUsageType(GPUUsageType)`` для смены стратегии.
5. Метод ``Use()`` делегирует выполнение текущей стратегии.

## Краткая характеристика паттерна "Стратегия"

**Паттерн "Стратегия"** определяет семейство алгоритмов (в нашем случае — способов использования видеокарт), инкапсулирует каждый из них и обеспечивает их взаимозаменяемость.
Это позволяет динамически изменять алгоритм без изменения кода клиента, который его использует.

# Шаблонный метод

## Задача

1. Унифицировать структуру метода Use() в GPU и его потомках (GeForce, Quadro, Tesla).
2. Уменьшить дублирование кода.

## Решение

1. Метод Use() в базовом классе фиксирует общий алгоритм (не виртуальный).
2. Выделить абстрактные этапы:
    - Инициализация устройства
    - Запуск специфических функций (DLSS, ECC, тензорные ядра)
    - Завершение работы
3. Повторяющийся код оставить в базовом классе.

## Краткая характеристика паттерна "Шаблонный метод"

**Паттерн "Шаблонный метод"** задает общий скелет алгоритма в методе родительского класса, позволяя унаследованным классам переопределять отдельные этапы.
Это позволяет изменять отдельные шаги алгоритма, не нарушая его общей структуры.